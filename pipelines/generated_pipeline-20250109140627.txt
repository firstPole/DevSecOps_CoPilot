Creating a CI/CD pipeline for deploying microservices to Amazon EKS (Elastic Kubernetes Service) using AWS CodeDeploy, Helm, and best practices is a multi-step process. Below, I will provide a sample pipeline definition using AWS CodePipeline and AWS CodeBuild, as well as guidance on other best practices.

### AWS CI/CD Pipeline Overview

1. **Source Stage**: Pull the source code from a repository (e.g., GitHub, CodeCommit).
2. **Build Stage**: Build the Docker image, run security/vulnerability scans, and push the image to Amazon ECR (Elastic Container Registry).
3. **Deploy Stage**: Use Helm to deploy the application to EKS.
4. **Monitoring and Rollback**: Use Kubernetes features and AWS services for monitoring and rollback.

### Sample AWS CodePipeline Configuration

Here's an example of how to define your AWS CodePipeline using AWS CLI or CloudFormation. 

#### Example CloudFormation Template

```yaml
AWSTemplateFormatVersion: '2010-09-09'
Resources:
  MyPipeline:
    Type: 'AWS::CodePipeline::Pipeline'
    Properties:
      Name: MyMicroservicePipeline
      RoleArn: arn:aws:iam::account-id:role/CodePipelineRole
      ArtifactStore:
        Type: S3
        Location: my-artifact-bucket
      Stages:
        - Name: Source
          Actions:
            - Name: SourceAction
              ActionTypeId:
                Category: Source
                Owner: ThirdParty
                Provider: GitHub
                Version: '1'
              OutputArtifacts:
                - Name: SourceOutput
              Configuration:
                Owner: my-github-username
                Repo: my-repo
                Branch: main
                OAuthToken: !Ref GitHubToken

        - Name: Build
          Actions:
            - Name: BuildAction
              ActionTypeId:
                Category: Build
                Owner: AWS
                Provider: CodeBuild
                Version: '1'
              InputArtifacts:
                - Name: SourceOutput
              OutputArtifacts:
                - Name: BuildOutput
              Configuration:
                ProjectName: !Ref CodeBuildProject

        - Name: Deploy
          Actions:
            - Name: DeployAction
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Provider: CodeDeploy
                Version: '1'
              InputArtifacts:
                - Name: BuildOutput
              Configuration:
                ApplicationName: MyApplication
                DeploymentGroupName: MyDeploymentGroup
```

### CodeBuild Project Example

You will need a CodeBuild project that builds your Docker image, performs security scans, and pushes the image to ECR. Below is a sample `buildspec.yml` file for CodeBuild.

```yaml
version: 0.2

phases:
  pre_build:
    commands:
      - echo Logging in to Amazon ECR...
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
      - REPOSITORY_URI=$ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/my-microservice
      - IMAGE_TAG=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)

  build:
    commands:
      - echo Building the Docker image...
      - docker build -t my-microservice .
      - docker tag my-microservice:latest $REPOSITORY_URI:latest
      - docker tag my-microservice:latest $REPOSITORY_URI:$IMAGE_TAG

  post_build:
    commands:
      - echo Pushing the Docker image...
      - docker push $REPOSITORY_URI:latest
      - docker push $REPOSITORY_URI:$IMAGE_TAG
```

### Helm Deployment Configuration

You will create a Helm chart to manage your Kubernetes resources. The chart should include:

- **Deployment**: Define how to deploy your microservice.
- **Service**: Expose your microservice.
- **Ingress** (if needed): To manage external access.
- **Values file**: For environment-specific configurations.

#### Example Helm Chart Structure

```
my-microservice-chart/
  ├── Chart.yaml
  ├── values.yaml
  ├── templates/
      ├── deployment.yaml
      ├── service.yaml
      ├── ingress.yaml
```

### Security Considerations

1. **Vulnerability Scanning**: Implement tools like Trivy or Clair in your CodeBuild phase to scan Docker images for vulnerabilities.
2. **IAM Roles**: Follow the principle of least privilege for IAM roles used by your pipeline.
3. **Secrets Management**: Use AWS Secrets Manager or Parameter Store to manage sensitive information.

### Monitoring and Rollback

1. **Monitoring**: Utilize AWS CloudWatch and EKS monitoring tools to track the health and performance of your microservices.
2. **Self-Healing**: Kubernetes automatically restarts failed containers.
3. **Rollback**: Use Helm’s rollback feature (`helm rollback`) to revert to a previous deployment if necessary.

### Guidance Document

#### Step-by-Step Deployment Guide

1. **Set Up Your AWS Environment**: Ensure your IAM roles, S3 buckets, and ECR repositories are properly configured.
2. **Create Your Helm Chart**: Define your Kubernetes resources in the Helm chart.
3. **Configure CodeBuild**: Create the `buildspec.yml` file with the appropriate commands to build and push your Docker image.
4. **Set Up CodePipeline**: Define your pipeline using the CloudFormation template provided.
5. **Run Your Pipeline**: Trigger the pipeline and monitor the output for any issues.
6. **Deploy and Test**: After deployment, validate the application functionality and performance.

By following this structure and guidance, you can set up a robust CI/CD pipeline for deploying microservices to EKS using AWS services while adhering to best practices for security, monitoring, and maintainability.